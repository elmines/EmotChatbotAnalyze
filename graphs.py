import sys
import collections
import argparse

import matplotlib
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np


_LEFT_QUOTE = "\u201C"
_RIGHT_QUOTE = "\u201D"

def create_parser():
	parser = argparse.ArgumentParser(description="Take responses generated by a chatbot and produce graphs showing statistics on them."
							"Either specify --input and --col or pass responses to standard input.")

	parser.add_argument("--input", "-i", metavar="responses.xlsx", nargs="+", help="Spreadsheet(s) containing the responses as one of the columns.")
	parser.add_argument("--col", "-c", metavar="column_name", nargs="+",  help="Column name from which to obtain responses. Pass in one name to use the same name for all --input's")


	parser.add_argument("--title", metavar="<Title>", type=str, help="Title to display for the entire plot")
	parser.add_argument("--model-names", metavar="<Subtitle>", nargs="+", help="Titles for each subplot when providing multiple --input's")

	parser.add_argument("--max", metavar="N", type=int, default=10, help="Maximum number of categories to have a in a pie graph")

	parser.add_argument("--styles", metavar="<path>.mplstyle", nargs="+", type=str, help="Matplotlib style sheets to customize graph")

	parser.add_argument("--multibar", action="store_true", help="Graph percentages from different models on one bar graph")


	return parser

def multi_percent_data(responses, max_cat):
	"""
	:param list(list(str))   responses: List of responses for each model
	:param int           max_cat: Maximum number of categories
	:param float     min_percent: Preferred minimum % of pie graph to cover with non-<Other> categories"

	:return Tuple of text labels and corresponding percentages
	"""

	counters = [collections.Counter(response_set) for response_set in responses]
	num_cat = min(max_cat, max(len(counter.keys()) for counter in counters))
	print(num_cat)
	responses_by_model = [sorted(counter.keys(), key=counter.get, reverse=True) for counter in counters]

	num_models = len(responses)
	response_indices = [0] * num_models

	categories = []
	counts= [ [] for _ in range(num_models) ]
	while len(categories) < num_cat:

		#Greedily pick the next response with the highest percentage for a single model
		highest_count = -1
		next_response = None
		for i in range(num_models):
			#print(i)
			candidate_response = responses_by_model[i][response_indices[i]]
			count = counters[i][candidate_response]
			if count > highest_count:
				highest_count = count
				next_response = candidate_response
		assert next_response is not None


		for i in range(num_models):
			curr_response = responses_by_model[i][response_indices[i]]
			if next_response == curr_response:
				response_indices[i] += 1	

		for i, count_set in enumerate(counts):
			count_set.append(counters[i].get(next_response, 0))
		categories.append(next_response)

	return counts, categories


def multibar(responses, model_names, max_cat=10, min_percent=0.90, suptitle=None):
	"""
	:param list(list(str)) responses: Responses for each model
	:param int               max_cat: Maximum number of categories
	:param float         min_percent: Preferred minimum % of pie graph to cover with non-<Other> categories"


	"""	

	assert len(responses) == len(model_names)

	(counts, categories) = multi_percent_data(responses, max_cat)

	width = 0.35
	bar_width = width / len(model_names)

	indices = np.arange(len(categories))

	#indices + (i * width)

	fig, axes = plt.subplots()
	for i, model in enumerate(model_names):


		axes.bar( (indices - width / 2) + ( (i) * bar_width), counts[i], bar_width, label=model)
		#axes.bar(indices + (i*bar_width), counts[i], width, label=model)

	axes.set_xticklabels(categories, rotation=45)
	axes.set_xlabel("Responses")
	axes.set_ylabel("Frequency")
	axes.legend()	



	plt.show()



def pie_graph(responses, max_cat=10, suptitle=None):
	"""
	:param list(str) responses: Responses for a single model
	"""

	(counts, categories) = multi_percent_data([responses], max_cat)
	counts = counts[0]

	#labels = ["{1}\n{0:.2%}".format(percentage, category) for percentage, category in zip(percentages, categories)]
	fig, axes = plt.subplots()
	if suptitle is not None: fig.suptitle(suptitle)
	axes.pie(counts, labels=categories)
	axes.set_aspect("equal")
	plt.show()

#def bar_graph(responses, max_cat=10, min_percent=0.90, suptitle=None):
	


if __name__ == "__main__":
	parser = create_parser()
	args = parser.parse_args()

	if args.input is None:
		lines = []
		sys.stderr.write("Reading sequences from standard input. . .\n")
		line = sys.stdin.readline()
		while line:
			lines.append(line.strip())
			line = sys.stdin.readline()
		lines = [lines]
	else:
		if args.col is None:
			sys.stderr.write("Must specify both --input and --col.\n")
			sys.exit(0)
		elif len(args.col) == 1:
			args.col *= len(args.input)
		lines = [ list(pd.read_excel(path)[args.col[i]]) for i, path in enumerate(args.input)]


	if args.styles is not None:
		plt.style.use(args.styles)

	if args.multibar:
		multibar(lines, args.model_names, max_cat=args.max, suptitle=args.title)
	else:
		pie_graph(lines[0], max_cat=args.max, suptitle=args.title)
