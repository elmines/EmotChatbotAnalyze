"""
Module for graphing a chatbot's performance with Matplotlib
"""
import sys
import collections
import argparse

import matplotlib
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np


def create_parser():
	"""
	Generates the parser for parsing command-line arguments

	:returns: The parser
	:rtype: argparse.ArgumentParser
	"""
	parser = argparse.ArgumentParser(description="Take responses generated by a chatbot and produce graphs showing statistics on them."
							"Either specify --input and --col or pass responses to standard input.")

	parser.add_argument("--input", "-i", metavar="responses.xlsx", nargs="+", help="Spreadsheet(s) containing the responses as one of the columns.")
	parser.add_argument("--col", "-c", metavar="column_name", nargs="+",  help="Column name from which to obtain responses. Pass in one name to use the same name for all --input's")

	parser.add_argument("--cats", metavar="\"How are you?\"", nargs="+", help="Prespecified responses to use as categories")
	parser.add_argument("--indices", metavar="n", type=int, nargs="+", help="Used with --cat, specifies the exclusive array indices by which to group responses in --cat")


	parser.add_argument("--title", metavar="<Title>", type=str, help="Title to display for the entire plot")
	parser.add_argument("--model-names", metavar="<Subtitle>", nargs="+", help="Titles for each subplot when providing multiple --input's")

	parser.add_argument("--max", metavar="N", type=int, default=10, help="Maximum number of categories to have a in a pie graph")

	parser.add_argument("--styles", metavar="<path>.mplstyle", nargs="+", type=str, help="Matplotlib style sheets to customize graph")

	parser.add_argument("--multibar", action="store_true", help="Graph percentages from different models on one bar graph")
	parser.add_argument("--horiz", action="store_true", help="Where applicable, make graph horizontal instead of vertical (i.e. --multibar)")

	return parser

def quote(text):
	"""
	Adds curly double quotes like so: \u201CDon't you prefer fancy quotes?\u201D

	:param str text: The text to be enclosed in quotes

	:returns: The quoted text
	:rtype:   str
	"""
	return "{0}{1}{2}".format("\u201C", text, "\u201D")

def count_cats(responses, max_cat):
	"""
	:param list(list(str))   responses: List of responses for each model
	:param int                 max_cat: Maximum number of categories
	:param float           min_percent: Preferred minimum % of pie graph to cover with non-<Other> categories"

	:return: Tuple of counts and their corresponding text labels
	:rtype:  tuple(list(list(int)), list(str))
	"""

	counters = [collections.Counter(response_set) for response_set in responses]
	num_cat = min(max_cat, max(len(counter.keys()) for counter in counters))
	responses_by_model = [sorted(counter.keys(), key=counter.get, reverse=True) for counter in counters]

	num_models = len(responses)
	response_indices = [0] * num_models

	categories = []
	counts= [ [] for _ in range(num_models) ]

	def model_response(m):
		"""
		:param int m: Index of the model into response_indices, responses_by_model, etc.
		:returns: The next unique response of m or its last response, depending on whether its responses have been exhausted
		:rtype: str
		"""
		if response_indices[m] >= len(responses_by_model[m]):
			return responses_by_model[m][-1] #Just keep returning the last response
		return responses_by_model[m][response_indices[m]]

	while len(categories) < num_cat - 1:
		#Greedily pick the next response with the highest percentage for a single model
		highest_count = -1
		next_response = None
		for m in range(num_models):
			candidate_response = model_response(m)
			while candidate_response in categories: #Ensures we don't have duplicates later on
				response_indices[m] += 1
				candidate_response = model_response(m)

			count = counters[m][candidate_response]
			if count > highest_count:
				highest_count = count
				next_response = candidate_response

		#Increment indices for any models that had next_response at their current index
		for m in range(num_models):
			curr_response = model_response(m)
			if next_response == curr_response:
				response_indices[m] += 1	

		#Add the counts for next_resposne
		for m, count_set in enumerate(counts):
			count_set.append(counters[m].get(next_response, 0))
		categories.append(next_response)

	#All the models have exactly one, identical category remaining
	if all(response_indices[m] == len(responses_by_model[m]) - 1 for m in range(num_models)):
		candidate_last = model_response(0)
		if all(model_response(m) == candidate_last for m in range(num_models)):
			categories.append(candidate_last)
			for i, count_set in enumerate(counts):
				count_set.append(counters[i][candidate_last])

		categories = [quote(category) for category in categories]
	else:
		categories = [quote(category) for category in categories]
		categories.append("<Other>")
		for i, count_set in enumerate(counts):
			count_set.append( sum(counters[i][phrase] for phrase in responses_by_model[i][response_indices[i]: ]) )
		

	return counts, categories


def _count_predefs(responses, predef):
	"""
	:param list(list(str))   responses: Responses for each model where responses[i][j] is the jth response of the ith model
	:param list(list(str))      predef: Predefined category \"groups, \" such as [[\"Yes\", \"Yeah\", \"Of course\"], [\"No\", \"Heck, no\", \"Never\"]]

	:returns: Tuple of counts and their corresponding text labels
	:rtype:  tuple(list(list(int)), list(str))
	"""
	model_counts = []
	for model_i_responses in responses:
		model_i_counts = [0 for _ in range(len(predef))]
		for response in model_i_responses:
			for (j, group) in enumerate(predef):
				if response in group: model_i_counts[j] += 1
		other_count = len(model_i_responses) - sum(model_i_counts)
		model_i_counts.append(other_count)
		model_counts.append(model_i_counts)


	quoted_predef = [[quote(response) for response in group] for group in predef]

	labels = ["/\n".join(group) for group in quoted_predef] + ["<Other>"]

	return (model_counts, labels)
					

def multibar(responses, model_names, max_cat=10, suptitle=None, horiz=False, predef=None):
	"""
	Graphs the frequencies of different models' responses

	:param list(list(str))   responses: Responses for each model where responses[i][j] is the jth response of the ith model
	:param list(str)       model_names: Names for each of the models (used for legends)
	:param int                 max_cat: Maximum number of categories
	:param str                suptitle: Title for the plot
	:param boolean               horiz: Plot a horizontal bar graph rather than a vertical one
	:param list(list(str))      predef: Predefined category \"groups, \" such as [[\"Yes\", \"Yeah\", \"Of course\"], [\"No\", \"Heck, no\", \"Never\"]]
	"""	

	if predef is None:
		(counts, categories) = count_cats(responses, max_cat)
	else:
		(counts, categories) = _count_predefs(responses, predef)


	width = 0.5
	bar_width = width / len(model_names)
	indices = np.arange(len(categories))


	fig, axes = plt.subplots()
	if suptitle is not None: fig.suptitle(suptitle)
	coords = [indices - width/2 + i*bar_width for i in range(len(model_names))]
	if horiz:
		reverse = lambda seq: [seq[-i-1] for i in range(len(seq))]
		counts = [reverse(count_set) for count_set in counts]
		categories  = reverse(categories)
		coords = reverse(coords) # Just for apppearances, so the bar colors are in the same order as the legend's colors
		bar_func = axes.barh
	else:
		bar_func = axes.bar


	for i, model in enumerate(model_names):
		bar_func(coords[i], counts[i], bar_width, label=model)

	if horiz:
		axes.set_yticks(indices)
		axes.set_yticklabels(categories)
		axes.tick_params("y", length=0)
		axes.set_xlabel("Frequency")
		axes.set_ylabel("Responses")
	else:
		axes.set_xticks(indices)
		axes.set_xticklabels(categories, rotation=90)
		axes.tick_params("x", length=0)
		axes.set_xlabel("Responses")
		axes.set_ylabel("Frequency")
	axes.legend()	

	plt.show()



def pie_graph(responses, max_cat=10, suptitle=None):
	"""
	Graphs the relative percentages of a chatbot's responses in a pie chart

	:param list(str) responses: Responses for a single model
	:param int                 max_cat: Maximum number of categories (i.e. pie wedges)
	:param str                suptitle: Title for the plot
	"""

	(counts, categories) = count_cats([responses], max_cat)
	counts = counts[0]

	#labels = ["{1}\n{0:.2%}".format(percentage, category) for percentage, category in zip(percentages, categories)]
	fig, axes = plt.subplots()
	if suptitle is not None: fig.suptitle(suptitle)
	axes.pie(counts, labels=categories)
	axes.set_aspect("equal")
	plt.show()

if __name__ == "__main__":
	parser = create_parser()
	args = parser.parse_args()

	if args.input is None:
		lines = []
		sys.stderr.write("Reading sequences from standard input. . .\n")
		line = sys.stdin.readline()
		while line:
			lines.append(line.strip())
			line = sys.stdin.readline()
		lines = [lines]
	else:
		if args.col is None:
			sys.stderr.write("Must specify both --input and --col.\n")
			sys.exit(0)
		elif len(args.col) == 1:
			args.col *= len(args.input)
		lines = [ list(pd.read_excel(path)[args.col[i]]) for i, path in enumerate(args.input)]

	predef = None
	if args.cats:
		predef = args.cats
		if args.indices:
			predef = []
			prev_index = 0
			for index in args.indices:
				if index == prev_index: continue
				predef.append( args.cats[prev_index:index] )
				prev_index = index
			if prev_index < len(args.cats): predef.append(args.cats[prev_index:])


	if args.styles is not None:
		plt.style.use(args.styles)

	if args.multibar:
		multibar(lines, args.model_names, max_cat=args.max, suptitle=args.title, horiz=args.horiz, predef=predef)
	else:
		pie_graph(lines[0], max_cat=args.max, suptitle=args.title)
