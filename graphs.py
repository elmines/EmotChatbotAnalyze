import sys
import collections
import argparse

import matplotlib
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np


_LEFT_QUOTE = "\u201C"
_RIGHT_QUOTE = "\u201D"

def create_parser():
	parser = argparse.ArgumentParser(description="Take responses generated by a chatbot and produce graphs showing statistics on them."
							"Either specify --input and --col or pass responses to standard input.")

	parser.add_argument("--input", "-i", metavar="responses.xlsx", nargs="+", help="Spreadsheet(s) containing the responses as one of the columns.")
	parser.add_argument("--col", "-c", metavar="column_name", nargs="+",  help="Column name from which to obtain responses. Pass in one name to use the same name for all --input's")


	parser.add_argument("--title", metavar="<Title>", type=str, help="Title to display for the entire plot")
	parser.add_argument("--model-names", metavar="<Subtitle>", nargs="+", help="Titles for each subplot when providing multiple --input's")

	parser.add_argument("--max", metavar="N", type=int, default=10, help="Maximum number of categories to have a in a pie graph")

	parser.add_argument("--styles", metavar="<path>.mplstyle", nargs="+", type=str, help="Matplotlib style sheets to customize graph")

	parser.add_argument("--multibar", action="store_true", help="Graph percentages from different models on one bar graph")
	parser.add_argument("--horiz", action="store_true", help="Where applicable, make graph horizontal instead of vertical (i.e. --multibar)")


	return parser

def count_cats(responses, max_cat):
	"""
	:param list(list(str))   responses: List of responses for each model
	:param int           max_cat: Maximum number of categories
	:param float     min_percent: Preferred minimum % of pie graph to cover with non-<Other> categories"

	:return Tuple of counts and their corresponding text labels
	:rtype tuple(list(list(int)), list(str)
	"""

	counters = [collections.Counter(response_set) for response_set in responses]
	num_cat = min(max_cat, max(len(counter.keys()) for counter in counters))
	responses_by_model = [sorted(counter.keys(), key=counter.get, reverse=True) for counter in counters]

	num_models = len(responses)
	response_indices = [0] * num_models

	categories = []
	counts= [ [] for _ in range(num_models) ]
	while len(categories) < num_cat - 1:

		#Greedily pick the next response with the highest percentage for a single model
		highest_count = -1
		next_response = None
		for i in range(num_models):
			candidate_response = responses_by_model[i][response_indices[i]]
			count = counters[i][candidate_response]
			if count > highest_count:
				highest_count = count
				next_response = candidate_response
		assert next_response is not None


		for i in range(num_models):
			curr_response = responses_by_model[i][response_indices[i]]
			if next_response == curr_response:
				response_indices[i] += 1	

		for i, count_set in enumerate(counts):
			count_set.append(counters[i].get(next_response, 0))
		categories.append(next_response)

	#FIXME: Actually check for out-of-bounds indices on response_indices (here and elsewhere)
	if all(response_indices[i] == len(responses_by_model[i]) - 1 for i in range(num_models)):
		candidate_last = responses_by_model[0][response_indices[0]]
		if all(responses_by_model[response_indices[i]] == candidate_last for i in range(num_models)):
			categories.append(candidate_last)
			for i, count_set in enumerate(counts):
				count_set.append(counters[i][candidate_last])
	else:
		categories.append("<Other>")
		for i, count_set in enumerate(counts):
			count_set.append( sum(counters[i][phrase] for phrase in responses_by_model[i][response_indices[i]: ]) )
		

	return counts, categories


def multibar(responses, model_names, max_cat=10, suptitle=None, horiz=False):
	"""
	:param list(list(str))   responses: Responses for each model
	:param list(str)       model_names: Names for each of the models (used for legends)
	:param int                 max_cat: Maximum number of categories
	:param str                suptitle: Title for the plot
	:param boolean               horiz: Plot a horizontal bar graph rather than a vertical one

	"""	

	(counts, categories) = count_cats(responses, max_cat)

	width = 0.5
	bar_width = width / len(model_names)
	indices = np.arange(len(categories))


	fig, axes = plt.subplots()
	coords = [indices - width/2 + i*bar_width for i in range(len(model_names))]
	if horiz:
		reverse = lambda seq: [seq[-i-1] for i in range(len(seq))]
		counts = [reverse(count_set) for count_set in counts]
		categories  = reverse(categories)
		coords = reverse(coords) # Just for apppearances, so the bar colors are in the same order as the legend's colors
		bar_func = axes.barh
	else:
		bar_func = axes.bar


	for i, model in enumerate(model_names):
		bar_func(coords[i], counts[i], bar_width, label=model)

	if horiz:
		axes.set_yticks(indices)
		axes.set_yticklabels(categories)
		axes.tick_params("y", length=0)
		axes.set_xlabel("Frequency")
		axes.set_ylabel("Responses")
	else:
		axes.set_xticks(indices)
		axes.set_xticklabels(categories, rotation=90)
		axes.tick_params("x", length=0)
		axes.set_xlabel("Responses")
		axes.set_ylabel("Frequency")
	axes.legend()	

	plt.show()



def pie_graph(responses, max_cat=10, suptitle=None):
	"""
	:param list(str) responses: Responses for a single model
	"""

	(counts, categories) = count_cats([responses], max_cat)
	counts = counts[0]

	#labels = ["{1}\n{0:.2%}".format(percentage, category) for percentage, category in zip(percentages, categories)]
	fig, axes = plt.subplots()
	if suptitle is not None: fig.suptitle(suptitle)
	axes.pie(counts, labels=categories)
	axes.set_aspect("equal")
	plt.show()

#def bar_graph(responses, max_cat=10, min_percent=0.90, suptitle=None):
	


if __name__ == "__main__":
	parser = create_parser()
	args = parser.parse_args()

	if args.input is None:
		lines = []
		sys.stderr.write("Reading sequences from standard input. . .\n")
		line = sys.stdin.readline()
		while line:
			lines.append(line.strip())
			line = sys.stdin.readline()
		lines = [lines]
	else:
		if args.col is None:
			sys.stderr.write("Must specify both --input and --col.\n")
			sys.exit(0)
		elif len(args.col) == 1:
			args.col *= len(args.input)
		lines = [ list(pd.read_excel(path)[args.col[i]]) for i, path in enumerate(args.input)]


	if args.styles is not None:
		plt.style.use(args.styles)

	if args.multibar:
		multibar(lines, args.model_names, max_cat=args.max, suptitle=args.title, horiz=args.horiz)
	else:
		pie_graph(lines[0], max_cat=args.max, suptitle=args.title)
